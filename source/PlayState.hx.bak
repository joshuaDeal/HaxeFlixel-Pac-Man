package;

import flixel.FlxState;
import flixel.FlxG;
import flixel.addons.editors.ogmo.FlxOgmo3Loader;
import flixel.tile.FlxTilemap;
import flixel.group.FlxGroup;
import flixel.util.FlxColor;
import haxe.Timer;
import flixel.FlxCamera;
import flixel.math.FlxPoint;
import flixel.path.FlxPathfinder;
import flixel.path.FlxPath;
import flixel.sound.FlxSound;

class PlayState extends FlxState {
	private var player:Player;
	private var map:FlxOgmo3Loader;
	private var walls:FlxTilemap;
	private var intersections:FlxTypedGroup<Intersection>;
	private var dots:FlxTypedGroup<Dot>;
	private var bigDots:FlxTypedGroup<BigDot>;
	private var blinky:Ghost;
	private var pinky:Ghost;
	private var inky:Ghost;
	private var clyde:Ghost;
	private var score:Int = 0;
	private var lives:Int = Constants.LIVES;
	private var pathfinder = new BigMoverPathfinder(1, 1, NONE);
	private var diagonalPolicy:FlxTilemapDiagonalPolicy = NONE;
	private var simplify = FlxPathSimplifier.LINE;
	private var dotCount:Int = 0;
	private var hud:HUD;
	private var stage:Int = 1;
	private var ghostFleeDuration:Float = Constants.FLEE_TIME;
	private var ghostFleeTime:Map<Ghost, Float>;
	private var ghostPenTime:Map<Ghost, Float>;
	private var ghostModeTime:Int;
	private var isGameFrozen:Bool = false;
	private var dotSound:FlxSound = FlxG.sound.load("assets/sounds/dot.ogg");
	private var bigDotSound:FlxSound = FlxG.sound.load("assets/sounds/big_dot.ogg");
	private var ghostAteSound:FlxSound = FlxG.sound.load("assets/sounds/ghost_ate.ogg");
	private var playerAteSound:FlxSound = FlxG.sound.load("assets/sounds/player_ate.ogg");
	private var ghostRoamSound:FlxSound = FlxG.sound.load("assets/sounds/ghost_roam.ogg");
	private var ghostFleeSound:FlxSound = FlxG.sound.load("assets/sounds/ghost_flee.ogg");
	private var ghostEyeSound:FlxSound = FlxG.sound.load("assets/sounds/ghost_eyes.ogg");
	private var gameOverScreen:GameOverScreen;

	override public function create() {
		super.create();

		// Create and manage tilemap.
		map = new FlxOgmo3Loader("assets/data/pacman.ogmo", "assets/data/maze.json");
		walls = map.loadTilemap("assets/images/tiles.png", "walls");
		walls.follow();
		walls.setTileProperties(1, NONE);
		walls.setTileProperties(2, ANY);
		add(walls);

		// Create player
		player = new Player();
		add(player);

		// Create intersections
		intersections = new FlxTypedGroup<Intersection>();
		add(intersections);

		// Create dots.
		dots = new FlxTypedGroup<Dot>();
		add(dots);

		// Create big dots.
		bigDots = new FlxTypedGroup<BigDot>();
		add(bigDots);

		// Create ghosts.
		blinky = new Ghost();
		blinky.path = new FlxPath();
		blinky.path.immovable = false;
		add(blinky);
		pinky = new Ghost();
		pinky.path = new FlxPath();
		pinky.path.immovable = false;
		add(pinky);
		inky = new Ghost();
		inky.path = new FlxPath();
		inky.path.immovable = false;
		add(inky);
		clyde = new Ghost();
		clyde.path = new FlxPath();
		clyde.path.immovable = false;
		add(clyde);

		// Create timers.
		// Flee timers.
		ghostFleeTime = new Map<Ghost, Float>();
		ghostFleeTime.set(blinky, 0.0);
		ghostFleeTime.set(pinky, 0.0);
		ghostFleeTime.set(inky, 0.0);
		ghostFleeTime.set(clyde, 0.0);
		// Pen timers.
		ghostPenTime = new Map<Ghost, Float>();
		ghostPenTime.set(blinky, 0.0);
		ghostPenTime.set(pinky, 0.0);
		ghostPenTime.set(inky, 0.0);
		ghostPenTime.set(clyde, 0.0);
		// Mode timer.
		ghostModeTime = 0;

		// Create HUD.
		hud = new HUD();

		// Add entities to map. **This should be called after creating and adding each entity!**
		map.loadEntities(placeEntities, "entities");

		// Reset the ghosts.
		resetGhost(blinky);
		resetGhost(pinky);
		resetGhost(inky);
		resetGhost(clyde);

		// Create game over screen.
		gameOverScreen = new GameOverScreen();
		gameOverScreen.visible = false;
		add(gameOverScreen);

	}

	override public function update(elapsed:Float) {
		// Only update game when it is not frozen.
		if (!isGameFrozen) {
			super.update(elapsed);

			// Player controls.
			if (FlxG.keys.pressed.W || FlxG.keys.pressed.UP) {
				player.newDirection = Constants.Direction.UP;
			} else if (FlxG.keys.pressed.S || FlxG.keys.pressed.DOWN) {
				player.newDirection = Constants.Direction.DOWN;
			} else if (FlxG.keys.pressed.A || FlxG.keys.pressed.LEFT) {
				player.newDirection = Constants.Direction.LEFT;
			} else if (FlxG.keys.pressed.D || FlxG.keys.pressed.RIGHT) {
				player.newDirection = Constants.Direction.RIGHT;
			}

			//Move player.
			player.movePlayer();

			// Allow collisions between player and walls.
			FlxG.collide(player, walls);

			// Check if player is in intersection.
			for (intersection in intersections.members) {
				if (intersection.x == player.x && intersection.y == player.y) {
					player.changeDirection(intersection.getPossibleDirections(walls));
					break;
				}
			}

			// Check if player is touching a dot.
			FlxG.overlap(player, dots, playerTouchDot);
			FlxG.overlap(player, bigDots, playerTouchBigDot);

			// Manage ghosts.
			manageGhost(blinky, elapsed);
			manageGhost(pinky, elapsed);
			manageGhost(inky, elapsed);
			manageGhost(clyde, elapsed);

			ghostSounds();

			// Update ghost mode timer.
			ghostModeTime += Std.int(elapsed * 60);

			// Switch ghost modes.
			if (ghostModeTime >= 240) {
				toggleChaseScatter(blinky);
				toggleChaseScatter(pinky);
				toggleChaseScatter(inky);
				toggleChaseScatter(clyde);

				ghostModeTime = 0;
			}

			// Teleport player if player exits stage left or right.
			if (player.x <= -18) {
				player.x = 450;
			} else if (player.x >= 450) {
				player.x = -18;
			}

			// Basic win condition.
			if (dotCount == 0) {
				resetStage();
			}

			// Update HUD.
			hud.update();
		}
	}

	override public function draw():Void {
		super.draw();
		hud.draw();
	}

	private function freezeGame(duration:Int):Void {
		isGameFrozen = true;

		Timer.delay(unfreezeGame, duration);
	}

	private function unfreezeGame():Void {
		isGameFrozen = false;
	}

	private function resetStage():Void {
		// Increase stage.
		stage++;

		// Reset dots.
		resetDots();

		// Reset ghosts.
		resetGhost(blinky);
		resetGhost(pinky);
		resetGhost(inky);
		resetGhost(clyde);

		// Reset player
		resetPlayer();
	}

	private function resetDots() {
		// Clear existing dots.
		dots.clear();

		// Call placeEntities to re-add dots.
		map.loadEntities(placeEntities, "entities");
	}

	private function manageGhost(ghost:Ghost, elapsed:Float):Void {
		// Move ghost.
		if (ghost.mode == Constants.GhostMode.PEN || ghost.mode == Constants.GhostMode.FLEE) {
			ghost.moveGhost();
		} else if (ghost.mode == Constants.GhostMode.CHASE || ghost.mode == Constants.GhostMode.SCATTER) {
			//ghostFollowPath(ghost, Std.int(player.x), Std.int(player.y), elapsed);
			ghost.moveGhost();
		} else if (ghost.mode == Constants.GhostMode.EXIT_PEN) {
			ghostFollowPath(ghost, 216, 224, elapsed);
			//ghostFollowPath(ghost, 224, 224, elapsed);
		} else if (ghost.mode == Constants.GhostMode.ATE) {
			if (ghost == blinky)
				ghostFollowPath(ghost, 216, 224, elapsed);
				//ghostFollowPath(ghost, 224, 224, elapsed);
			else if (ghost == pinky)
				ghostFollowPath(ghost, 184, 256, elapsed);
				//ghostFollowPath(ghost, 192, 256, elapsed);
			else if (ghost == inky)
				ghostFollowPath(ghost, 216, 288, elapsed);
				//ghostFollowPath(ghost, 224, 288, elapsed);
			else if (ghost == clyde)
				ghostFollowPath(ghost, 248, 256, elapsed);
				//ghostFollowPath(ghost, 256, 256, elapsed);
		}

		// Allow collisions between ghost and walls.
		FlxG.collide(ghost, walls);

		// Slow ghosts down if they are in exit tunnle.
		if ((ghost.x < 96 && ghost.y == 272) || (ghost.x > 336 && ghost.y == 272)) {
			ghost.speed = Std.int(Constants.GHOST_SPEED / 2);
		} else if (ghost.mode != Constants.GhostMode.FLEE && ghost.speed != Constants.GHOST_SPEED) {
			ghost.speed = Constants.GHOST_SPEED;
		}

		// Teleport ghost if it exits stage left or right.
		if (ghost.x <= -18) {
			ghost.x = 450;
		} else if (ghost.x >= 450) {
			ghost.x = -18;
		}

		// Check if ghost is in intersection.
		for (intersection in intersections.members) {
			if (intersection.x == ghost.x && intersection.y == ghost.y) {
				// Pick direction.
				if (ghost.mode == Constants.GhostMode.CHASE) {
					if (ghost == blinky) {
						ghost.newDirection = ghost.findDirection(Std.int(player.x), Std.int(player.y), intersection.getPossibleDirections(walls));
					} else if (ghost == pinky) {
						// Target spot 64 pixels in front of player.
						var targetX:Int;
						var targetY:Int;

						// Determine pinky's target based on player's direction.
						switch (player.direction) {
							case Constants.Direction.LEFT:
								targetX = Std.int(player.x) - 64;
								targetY = Std.int(player.y);
							case Constants.Direction.RIGHT:
								targetX = Std.int(player.x) + 64;
								targetY = Std.int(player.y);
							case Constants.Direction.UP:
								targetX = Std.int(player.x);
								targetY = Std.int(player.y) - 64;
							case Constants.Direction.DOWN:
								targetX = Std.int(player.x);
								targetY = Std.int(player.y) + 64;
						}

						ghost.newDirection = ghost.findDirection(targetX, targetY, intersection.getPossibleDirections(walls));
					} else if (ghost == inky) {
						var targetX:Int;
						var targetY:Int;

						switch (player.direction) {
							case Constants.Direction.LEFT:
								targetX = Std.int(player.x) - 32;
								targetY = Std.int(player.y);
							case Constants.Direction.RIGHT:
								targetX = Std.int(player.x) + 32;
								targetY = Std.int(player.y);
							case Constants.Direction.UP:
								targetX = Std.int(player.x);
								targetY = Std.int(player.y) - 32;
							case Constants.Direction.DOWN:
								targetX = Std.int(player.x);
								targetY = Std.int(player.y) + 32;
						}

						// Calculate vector from blinky to new target position.
						var vectorX:Float = targetX - blinky.x;
						var vectorY:Float = targetY - blinky.y;

						// Double vector
						targetX = Std.int(blinky.x + vectorX * 2);
						targetY = Std.int(blinky.y + vectorY * 2);

						ghost.newDirection = ghost.findDirection(targetX, targetY, intersection.getPossibleDirections(walls));
					} else if (ghost == clyde) {
						var targetX:Int;
						var targetY:Int;

						// Find distance from player (Euclidean distance fromula).
						var distanceToPlayer: Float = Math.sqrt(Math.pow(Std.int(player.x) - ghost.x, 2) + Math.pow(Std.int(player.y) - ghost.y, 2));

						if (distanceToPlayer > 128) {
							targetX = Std.int(player.x);
							targetY = Std.int(player.y);
						} else {
							targetX = 0;
							targetY = 560;
						}

						ghost.newDirection = ghost.findDirection(targetX, targetY, intersection.getPossibleDirections(walls));
					}
				} else if (ghost.mode == Constants.GhostMode.SCATTER) {
					if (ghost == blinky) {
						var targetX = 432;
						var targetY = 32;
						ghost.newDirection = ghost.findDirection(targetX, targetY, intersection.getPossibleDirections(walls));
					} else if (ghost == pinky) {
						var targetX = 0;
						var targetY = 32;
						ghost.newDirection = ghost.findDirection(targetX, targetY, intersection.getPossibleDirections(walls));
					} else if (ghost == inky) {
						var targetX = 432;
						var targetY = 560;
						ghost.newDirection = ghost.findDirection(targetX, targetY, intersection.getPossibleDirections(walls));
					} else if (ghost == clyde) {
						var targetX = 0;
						var targetY = 560;
						ghost.newDirection = ghost.findDirection(targetX, targetY, intersection.getPossibleDirections(walls));
					}
				} else {
					ghost.newDirection = getRandomDirection();
				}

				ghost.changeDirection();
				break;
			}
		}

		// Manage flee timer.
		if (ghost.mode == Constants.GhostMode.FLEE) {
			ghostFleeTime.set(ghost, ghostFleeTime.get(ghost) + elapsed);
			if (ghostFleeTime.get(ghost) >= ghostFleeDuration) {
				makeGhostRoam(ghost);
			}
		}

		// Manage pen timer.
		if (ghost.mode == Constants.GhostMode.PEN) {
			ghostPenTime.set(ghost, ghostPenTime.get(ghost) + elapsed);
			if (ghost == blinky && ghostPenTime.get(ghost) >= 0.0) {
				freeGhost(ghost);
				// Reset pen timer.
				ghostPenTime.set(ghost, 0.0);
			} else if (ghost == pinky && ghostPenTime.get(ghost) >= 5.0) {
				freeGhost(ghost);
				// Reset pen timer.
				ghostPenTime.set(ghost, 0.0);
			} else if (ghost == inky && ghostPenTime.get(ghost) >= 10.0) {
				freeGhost(ghost);
				// Reset pen timer.
				ghostPenTime.set(ghost, 0.0);
			} else if (ghost == clyde && ghostPenTime.get(ghost) >= 15.0) {
				freeGhost(ghost);
				// Reset pen timer.
				ghostPenTime.set(ghost, 0.0);
			}
		}

		// Check for collision between ghost and player.
		if (FlxG.overlap(player, ghost)) {
			if (ghost.mode == Constants.GhostMode.FLEE) {
				ghostAte(ghost);
			} else if (ghost.mode == Constants.GhostMode.CHASE || ghost.mode == Constants.GhostMode.SCATTER) {
				playerAte();
			}
		}

		// Logic for ghost pen mode.
		if (ghost.mode == Constants.GhostMode.PEN) {
			//trace("Ghost is in PEN mode at y: " + ghost.y);
			if (ghost.y == 256) {
				//trace("Changing direction to DOWN.");
				ghost.newDirection = Constants.Direction.DOWN;
				ghost.changeDirection();
			} else if (ghost.y == 288) {
				//trace("Changing direction to UP.");
				ghost.newDirection = Constants.Direction.UP;
				ghost.changeDirection();
			}
		}
	}

	private function ghostSounds():Void {
		if (blinky.mode == Constants.GhostMode.ATE || pinky.mode == Constants.GhostMode.ATE || inky.mode == Constants.GhostMode.ATE || clyde.mode == Constants.GhostMode.ATE) {
			ghostEyeSound.play(false);
		} else if (blinky.mode == Constants.GhostMode.FLEE || pinky.mode == Constants.GhostMode.FLEE || inky.mode == Constants.GhostMode.FLEE || clyde.mode == Constants.GhostMode.FLEE) {
			ghostFleeSound.play(false);
		} else {
			ghostRoamSound.play(false);
		}
	}

	private function ghostFollowPath(ghost:Ghost, x:Int, y:Int, elapsed:Float):Void {
		// Find path to point.
		if (ghost.pathPoints == null || ghost.mode == Constants.GhostMode.CHASE) {
			// Center ghost on intersection.
			for (intersection in intersections.members) {
				if (FlxG.overlap(ghost, intersection)) {
					ghost.x = intersection.x;
					ghost.y = intersection.y;
					break;
				}
			}

			pathfinder.diagonalPolicy = diagonalPolicy;
			ghost.pathPoints = pathfinder.findPath(cast walls, FlxPoint.weak(ghost.x + ghost.width / 2, ghost.y + ghost.height / 2), FlxPoint.weak(x + ghost.width / 2, y + ghost.height / 2), simplify);
			ghost.path.start(ghost.pathPoints, 100.0, FORWARD, false, true);
		}

		// Follow path.
		if (ghost.pathPoints != null) {
			ghost.path.update(elapsed);
		}

		// Stop ghost
		if (ghost.x == x && ghost.y == y) {
			ghost.path.cancel();
			//ghost.velocity.x = ghost.velocity.y = 0;
			ghost.pathPoints = null;
			if (ghost.mode == Constants.GhostMode.EXIT_PEN) {
				makeGhostRoam(ghost);
				ghost.newDirection = Constants.Direction.LEFT;
				ghost.changeDirection();
			} else if (ghost.mode == Constants.GhostMode.ATE) {
				resetGhost(ghost);
			}
		}
	}

	private function resetGhost(ghost:Ghost):Void {
		// Remove paths.
		ghost.path.cancel();
		ghost.pathPoints = null;

		// Reset pen timer.
		ghostPenTime.set(ghost, 0.0);

		// Move ghost to pen.
		if (ghost == blinky) {
			ghost.x = 216;
			ghost.y = 224;
			//ghost.x = 224;
			//ghost.y = 224;
		} else if (ghost == pinky) {
			ghost.x = 184;
			ghost.y = 256;
			//ghost.x = 192;
			//ghost.y = 256;
		} else if (ghost == inky) {
			ghost.x = 216;
			ghost.y = 288;
			//ghost.x = 224;
			//ghost.y = 288;
		} else if (ghost == clyde) {
			ghost.x = 248;
			ghost.y = 256;
			//ghost.x = 256;
			//ghost.y = 256;
		}

		colorGhost(ghost);

		// Set ghost to pen mode.
		ghost.mode = Constants.GhostMode.PEN;
		//trace("Ghost is in " + ghost.mode + " mode.");
	}

	private function freeGhost(ghost:Ghost):Void {
		if (ghost.mode == Constants.GhostMode.PEN) {
			ghost.mode = Constants.GhostMode.EXIT_PEN;
		}
	}

	private function getRandomDirection():Constants.Direction {
		// Generate random integer.
		var randomIndex = Math.floor(Math.random() * 4);

		// Return a direction based on random index.
		switch (randomIndex) {
			case 0: return Constants.Direction.LEFT;
			case 1: return Constants.Direction.RIGHT;
			case 2: return Constants.Direction.UP;
			case 3: return Constants.Direction.DOWN;
			default: return Constants.Direction.LEFT;
		}
	}

	private function playerTouchDot(player:Player, dot:Dot) {
		if (dot.alive && dot.exists) {
			dot.kill();
			dotSound.play(false);
			score += Constants.DOT_VALUE;
			hud.addToScore(Constants.DOT_VALUE);
			dotCount--;
		}
	}

	private function playerTouchBigDot(player:Player, bigDot:BigDot) {
		if (bigDot.alive && bigDot.exists) {
			bigDot.kill();
			bigDotSound.play(false);
			score += Constants.BIG_DOT_VALUE;
			hud.addToScore(Constants.BIG_DOT_VALUE);
			dotCount--;

			makeGhostFlee(blinky);
			makeGhostFlee(pinky);
			makeGhostFlee(inky);
			makeGhostFlee(clyde);
		}
	}

	private function playerAte() {
		playerAteSound.play(false);

		// Reduce player lives.
		lives--;
		hud.removeLife();

		if (lives > 0) {

			// Reset Ghosts.
			resetGhost(blinky);
			resetGhost(pinky);
			resetGhost(inky);
			resetGhost(clyde);

			// Return player to starting position.
			resetPlayer();
		} else {
			remove(player);
			gameOverScreen.show();
		}
	}

	private function resetPlayer() {
		player.x = 216;
		player.y = 416;
		player.newDirection = Constants.Direction.LEFT;
		player.changeDirection();
		player.isVertical = false;
	}

	private function makeGhostFlee(ghost:Ghost):Void {
		if (ghost.mode == Constants.GhostMode.CHASE || ghost.mode == Constants.GhostMode.SCATTER || ghost.mode == Constants.GhostMode.FLEE) {
			ghost.mode = Constants.GhostMode.FLEE;

			// Reset flee timer.
			ghostFleeTime.set(ghost, 0.0);

			// Switch direction
			if (ghost.direction == Constants.Direction.LEFT) {
				ghost.newDirection = Constants.Direction.RIGHT;
			} else if (ghost.direction == Constants.Direction.RIGHT) {
				ghost.newDirection = Constants.Direction.LEFT;
			} else if (ghost.direction == Constants.Direction.UP) {
				ghost.newDirection = Constants.Direction.DOWN;
			} else if (ghost.direction == Constants.Direction.DOWN) {
				ghost.newDirection = Constants.Direction.UP;
			}

			// Change Graphic.
			ghost.makeGraphic(Constants.GHOST_SIZE, Constants.GHOST_SIZE, FlxColor.BLUE);

			// Change Speed.
			if (ghost.speed == Constants.GHOST_SPEED) {
				ghost.speed = Std.int(ghost.speed / 2);
			}
		}
	}

	private function makeGhostRoam(ghost:Ghost):Void {
		if (ghost.mode == Constants.GhostMode.FLEE || ghost.mode == Constants.GhostMode.EXIT_PEN) {
			//ghost.mode = Constants.GhostMode.SCATTER;
			ghost.mode = Constants.GhostMode.CHASE;

			colorGhost(ghost);

			ghost.speed = Constants.GHOST_SPEED;

			ghostFleeTime.set(ghost, 0.0);
		}
	}

	private function colorGhost(ghost:Ghost):Void {
		if (ghost == blinky)
			ghost.makeGraphic(Constants.GHOST_SIZE, Constants.GHOST_SIZE, FlxColor.RED);
		else if (ghost == pinky)
			ghost.makeGraphic(Constants.GHOST_SIZE, Constants.GHOST_SIZE, FlxColor.PINK);
		else if (ghost == inky)
			ghost.makeGraphic(Constants.GHOST_SIZE, Constants.GHOST_SIZE, FlxColor.CYAN);
		else if (ghost == clyde)
			ghost.makeGraphic(Constants.GHOST_SIZE, Constants.GHOST_SIZE, FlxColor.ORANGE);
	}

	private function ghostAte(ghost:Ghost):Void {
		ghostAteSound.play(false);
		ghost.mode = Constants.GhostMode.ATE;
		ghost.makeGraphic(Constants.GHOST_SIZE, Constants.GHOST_SIZE, FlxColor.GREEN);
		freezeGame(500);
	}

	private function toggleChaseScatter(ghost:Ghost):Void {
		if (ghost.mode == Constants.GhostMode.CHASE) {
			ghost.mode = Constants.GhostMode.SCATTER;
		} else if (ghost.mode == Constants.GhostMode.SCATTER) {
			ghost.mode = Constants.GhostMode.CHASE;
		}
	}

	private function placeEntities(entity:EntityData):Void {
		if (entity.name == "player" && stage == 1) {
			player.setPosition(entity.x, entity.y);
		} else if (entity.name == "intersection" && stage == 1) {
			intersections.add(new Intersection(entity.x, entity.y));
		} else if (entity.name == "dot") {
			dots.add(new Dot(entity.x, entity.y));
			dotCount++;
		} else if (entity.name == "bigDot") {
			bigDots.add(new BigDot(entity.x, entity.y));
			dotCount++;
		} else if (entity.name == "blinky" && stage == 1) {
			blinky.setPosition(entity.x, entity.y);
		} else if (entity.name == "pinky" && stage == 1) {
			pinky.setPosition(entity.x, entity.y);
		} else if (entity.name == "inky" && stage == 1) {
			inky.setPosition(entity.x, entity.y);
		} else if (entity.name == "clyde" && stage == 1) {
			clyde.setPosition(entity.x, entity.y);
		}
	}
}
